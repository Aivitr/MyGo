琢磨了一下切片和数组的关系。虽然查到的资料里提到的什么编译期特性、运行时特性等太底层的东西我不明白，但自认为日常的使用不再有疑问了。我的学习结果如下：

我把数组看作是“数据本身”(所谓**值类型**),而将切片理解为对某一个底层匿名数组的引用(所谓**引用类型**),这点直接导致了二者的各种行为差异。

我自己学习的时候是从函数传参来理解的：

```go
package main

import "fmt"

//尝试修改切片元素
func changeElement(s []int) {
	s[0] = 999
}

func main() {

	arr := [5]int{1,2,3,4,5}
	s := arr[1:3]

	fmt.Println(s) //   [2 3]

	changeElement(s) // 这里传递进去的是切片副本，但是副本的指针还是指向arr
    fmt.Println(arr)    //  [1 999 3 4 5]（可以看到底层数组被修改)
	fmt.Println(s) //  [999 3]（底层数组arr被改变，那么切片元素自然也就改变）
}
```

而如果对函数传入一个数组，由于是值传递，函数执行完后这个数组将不会有任何改变,这很显然。
(不是为了偷懒不敲代码 awa)

另外，对于一个数组 arr(长度为 N)，创建切片 s = arr[m,n]相当于从 arr[m]“切”到 arr[n-1]。此时 s 的索引 0 即对应 arr 的索引 m(我将 m 理解为**指针指向的起点位置**)。这样来看的话 s 的容量就很直观，应当从 arr[m]开始向后算，即 cap(s) = N - m。沿用上面的例子：

```go
    arr := [5]int{1,2,3,4,5}
    s := arr[1:3]
    //位置对应起来看就是这样：
    //             arr  ：  1  |2  3|  4  5  |
    //             s    ：     |2  3|        |
    //cap从这里开始            |→→→→→→

```

当然还要注意“扩容”的问题，例如当通过 append 等手段追加元素使切片长度超过 cap,触发扩容，**那么从本次扩容操作开始切片就不再与原底层数组相关**,指针将指向一个匿名新数组：

```go
package main

import "fmt"

func appendAndChangeButExpand(s []int) {
	s = append(s, 6)
	s[0] = 999
}

func main() {

    arr := [5]int{1, 2, 3, 4, 5}
    s := arr[3:5]  //此时cap(s)=len(s)，已达容量上限

    appendAndChangeButExpand(s)//本次扩容导致切片副本指针指向新的匿名数组
    /*(我查到可以调用unsafe包来查看这个数组，但是AI告诉我unsafe指针真的非常的unsafe，非必要别这么干，那这里我就不展示了awa)*/
    fmt.Println(s) //   [4 5]（切片元素完全没变)
    fmt.Println(arr)//  [1,2,3,4,5]（原本的底层数组也没变）
}
```
