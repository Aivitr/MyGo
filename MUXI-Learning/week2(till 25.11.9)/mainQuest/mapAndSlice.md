# Map 与 Slice 扩容区别
---

## Slice
### 1. 扩容条件
当你使用 `append`，使`len()` = `cap()`，就会自动扩容。


### 2. 扩容后cap()怎么变
- 如果扩容前`cap() <= 1024` ，则`cap() = cap() * 2`
- 如果扩容前`cap() > 1024`，则`cap() = cap() * 1.25 `(节省空间)
- 特殊的，如果添加元素过多，切片将直接扩到刚好能装下所有元素的大小。

### 3. 扩容时到底发生了什么
1. 指向一个新的、更大的底层数组
2. 旧的数组中的元素copy进入新数组
3. 若再无切片指向旧数组，旧数组将会被GC回收。


## 二、Map
### 1. 扩容条件
Map 扩容分两种情况触发：
- 装填因子过高(大于6.5)
- 溢出桶（解决哈希冲突的额外桶）数量超过桶数组总数，导致查询效率下降

### 2. 扩容后变多大？
相应的，有两种扩容方式：
- 增加桶数量，降低装填因子
- 重新哈希迁移数据，缩短冲突链

### 3. 扩容时发生了什么？
- 创建新桶数组（增量扩容翻倍，等量扩容不变）
- 将原桶数组赋值给 oldbuckets，新桶数组赋值给 buckets，nevacuate（已迁移桶数）设为 0
- 后续对 Map 执行增删改查操作时，顺带迁移 1~2 个旧桶的数据至新桶，同步更新 nevacuate
- 所有旧桶数据迁移完毕后，oldbuckets 设为 nil，增量扩容时更新 B（桶数组大小指数），扩容结束


---


## 总结
- Slice 扩容是一次性拷贝 + 连续数组替换，牺牲短期阻塞换取连续内存访问效率
- Map 扩容是渐进式迁移 + 哈希表重组，牺牲短期内存翻倍换取无阻塞操作与低冲突效率
- 两者均为引用类型，扩容不改变变量本身的引用属性